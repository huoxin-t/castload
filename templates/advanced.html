<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Castbox æ’­å®¢æ•°æ®ç®¡ç†å™¨</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        /* åŸºç¡€æ ·å¼ */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        h1 {
            background: linear-gradient(135deg, #2c5aa0, #1e3d6f);
            color: white;
            margin: 0;
            padding: 25px 30px;
            text-align: center;
            font-size: 2.2em;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        /* é…ç½®é¢æ¿ */
        .config-panel {
            padding: 25px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .config-title {
            font-size: 1.4em;
            font-weight: 600;
            color: #2c5aa0;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }
        
        input[type="url"], input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }
        
        input[type="url"]:focus, input[type="number"]:focus {
            border-color: #2c5aa0;
            outline: none;
            box-shadow: 0 0 0 3px rgba(44, 90, 160, 0.1);
        }
        
        .help-text {
            font-size: 14px;
            color: #888;
            margin-top: 5px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }
        
        .range-inputs {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .range-inputs input {
            flex: 1;
        }
        
        .range-inputs span {
            font-weight: 500;
            color: #555;
        }
        
        .btn-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #2c5aa0, #1e3d6f);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #6c757d, #5a6268);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #28a745, #218838);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* çŠ¶æ€æ¶ˆæ¯ */
        .status-message {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-weight: 500;
            display: none;
        }
        
        .status-success {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background: linear-gradient(135deg, #f8d7da, #f1b0b7);
            color: #721c24;
            border: 1px solid #f1b0b7;
        }
        
        .status-info {
            background: linear-gradient(135deg, #d1ecf1, #b8daff);
            color: #0c5460;
            border: 1px solid #b8daff;
        }
        
        /* åŠ è½½åŠ¨ç”» */
        .loading {
            text-align: center;
            padding: 30px;
            display: none;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2c5aa0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* æ’­å®¢åˆ—è¡¨é€‰æ‹©åŒºåŸŸ */
        .episodes-selection {
            padding: 30px;
        }
        
        .episodes-selection h2 {
            color: #2c5aa0;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .selection-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .selection-controls .btn {
            padding: 10px 20px;
            font-size: 14px;
        }
        
        .episodes-list-container {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background: #fafafa;
        }
        
        .episode-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: all 0.2s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .episode-item:last-child {
            border-bottom: none;
        }
        
        .episode-item:hover {
            background: #f0f8ff;
            transform: translateX(5px);
        }
        
        .episode-item.selected {
            background: #e3f2fd;
            border-left: 4px solid #2c5aa0;
        }
        
        .episode-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .episode-title {
            flex: 1;
            font-size: 16px;
            color: #333;
            word-break: break-word;
        }
        
        /* é€‰æ‹©è®¡æ•° */
        .selection-count {
            text-align: center;
            margin: 20px 0;
            font-size: 18px;
            font-weight: 500;
            color: #2c5aa0;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            h1 {
                padding: 20px;
                font-size: 1.8em;
            }
            
            .config-panel, .episodes-selection {
                padding: 20px;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
            
            .selection-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .episodes-list-container {
                max-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§ Castbox æ’­å®¢æ•°æ®ç®¡ç†å™¨</h1>
        
        <!-- é…ç½®é¢æ¿ -->
        <div class="config-panel">
            <div class="config-title">æ’­å®¢çˆ¬å–é…ç½®</div>
            
            <div class="form-group">
                <label for="podcast-url">æ’­å®¢åˆ—è¡¨åœ°å€:</label>
                <input type="url" id="podcast-url" placeholder="è¯·è¾“å…¥ Castbox æ’­å®¢åˆ—è¡¨åœ°å€...">
                <div class="help-text">æ”¯æŒ Castbox å¹³å°çš„æ’­å®¢åˆ—è¡¨é¡µé¢åœ°å€</div>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="enable-limit">
                        <label for="enable-limit">é™åˆ¶ä¸‹è½½æ•°é‡</label>
                    </div>
                    <input type="number" id="download-limit" min="1" max="100" value="3" disabled>
                    <div class="help-text">æœ€å¤šä¸‹è½½å¤šå°‘ä¸ªæ’­å®¢</div>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="enable-range" checked>
                        <label for="enable-range">æŒ‡å®šä¸‹è½½èŒƒå›´</label>
                    </div>
                    <div class="range-inputs">
                        <input type="number" id="range-start" min="0" value="0" placeholder="å¼€å§‹">
                        <span>åˆ°</span>
                        <input type="number" id="range-end" min="1" value="10" placeholder="ç»“æŸ">
                    </div>
                    <div class="help-text">ä»ç¬¬å‡ ä¸ªå¼€å§‹ï¼Œåˆ°ç¬¬å‡ ä¸ªç»“æŸï¼ˆä»0å¼€å§‹è®¡æ•°ï¼‰</div>
                </div>
                
                <div class="form-group">
                    <label for="max-workers">å¹¶å‘çº¿ç¨‹æ•°:</label>
                    <input type="number" id="max-workers" min="1" max="8" value="5">
                    <div class="help-text">åŒæ—¶ä¸‹è½½çš„çº¿ç¨‹æ•°é‡</div>
                </div>
                
                <div class="form-group">
                    <label for="batch-size">åˆ†æ‰¹åŠ è½½æ•°é‡:</label>
                    <input type="number" id="batch-size" min="1" max="50" value="10">
                    <div class="help-text">æ¯æ¬¡åŠ è½½çš„æ’­å®¢æ•°é‡</div>
                </div>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="enable-retry" checked>
                        <label for="enable-retry">å¯ç”¨é‡è¯•æœºåˆ¶</label>
                    </div>
                    <input type="number" id="retry-count" min="1" max="5" value="3">
                    <div class="help-text">ä¸‹è½½å¤±è´¥æ—¶çš„é‡è¯•æ¬¡æ•°</div>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="enable-timeout" checked>
                        <label for="enable-timeout">å¯ç”¨è¶…æ—¶è®¾ç½®</label>
                    </div>
                    <input type="number" id="timeout-seconds" min="10" max="300" value="60">
                    <div class="help-text">å•ä¸ªæ–‡ä»¶ä¸‹è½½è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰</div>
                </div>
            </div>
            
            <div class="btn-group">
                <button onclick="loadEpisodes()" id="loadBtn" class="btn btn-primary">
                    ğŸ“¥ åŠ è½½æ’­å®¢åˆ—è¡¨
                </button>
                <button onclick="saveConfig()" class="btn btn-secondary">
                    ğŸ’¾ ä¿å­˜é…ç½®
                </button>
                <button onclick="downloadSelected()" id="downloadSelected" class="btn btn-success" disabled>
                    â¬‡ï¸ ä¸‹è½½é€‰ä¸­é¡¹
                </button>
                <a href="/history.html" class="btn btn-secondary">
                    ğŸ“š ä¸‹è½½å†å²
                </a>
            </div>
        </div>
        
        <!-- çŠ¶æ€æ¶ˆæ¯ -->
        <div id="status-message" class="status-message"></div>
        
        <!-- åŠ è½½åŠ¨ç”» -->
        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            <div>ğŸ“¡ æ­£åœ¨åŠ è½½æ’­å®¢åˆ—è¡¨...</div>
            <div style="margin-top: 10px;">â³ é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…</div>
        </div>
        
        <!-- æ’­å®¢åˆ—è¡¨é€‰æ‹©åŒºåŸŸ -->
        <div id="episodes-selection" class="episodes-selection" style="display: none;">
            <h2>ğŸ“‹ æ’­å®¢åˆ—è¡¨</h2>
            
            <div class="selection-controls">
                <button onclick="selectAll()" class="btn btn-secondary">å…¨é€‰</button>
                <button onclick="deselectAll()" class="btn btn-secondary">å…¨ä¸é€‰</button>
                <button onclick="invertSelection()" class="btn btn-secondary">åé€‰</button>
                <button onclick="selectFromZero()" class="btn btn-secondary">ä»0å¼€å§‹é€‰æ‹©</button>
            </div>
            
            <div class="selection-count">
                å·²é€‰æ‹© <span id="selected-count">0</span> ä¸ªæ’­å®¢
            </div>
            
            <div id="episodes-list-container" class="episodes-list-container">
                <!-- æ’­å®¢åˆ—è¡¨å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </div>
        </div>
    </div>

    <script>
        let currentEpisodes = [];
        let selectedEpisodes = new Set();
        
        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
        });
        
        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // å¤é€‰æ¡†äº‹ä»¶ç›‘å¬
            const enableLimit = document.getElementById('enable-limit');
            const enableRange = document.getElementById('enable-range');
            const enableRetry = document.getElementById('enable-retry');
            const enableTimeout = document.getElementById('enable-timeout');
            
            if (enableLimit) {
                enableLimit.addEventListener('change', function() {
                    const downloadLimit = document.getElementById('download-limit');
                    if (downloadLimit) {
                        downloadLimit.disabled = !this.checked;
                    }
                    if (this.checked) {
                        const enableRangeEl = document.getElementById('enable-range');
                        if (enableRangeEl) enableRangeEl.checked = false;
                    }
                });
            }
            
            if (enableRange) {
                enableRange.addEventListener('change', function() {
                    const rangeStart = document.getElementById('range-start');
                    const rangeEnd = document.getElementById('range-end');
                    if (rangeStart) rangeStart.disabled = !this.checked;
                    if (rangeEnd) rangeEnd.disabled = !this.checked;
                    if (this.checked) {
                        const enableLimitEl = document.getElementById('enable-limit');
                        if (enableLimitEl) enableLimitEl.checked = false;
                    }
                });
            }
            
            if (enableRetry) {
                enableRetry.addEventListener('change', function() {
                    const retryCount = document.getElementById('retry-count');
                    if (retryCount) {
                        retryCount.disabled = !this.checked;
                    }
                });
            }
            
            if (enableTimeout) {
                enableTimeout.addEventListener('change', function() {
                    const timeoutSeconds = document.getElementById('timeout-seconds');
                    if (timeoutSeconds) {
                        timeoutSeconds.disabled = !this.checked;
                    }
                });
            }
        }
        
        // ä¿å­˜é…ç½®
        async function saveConfig() {
            const config = {
                podcast_url: document.getElementById('podcast-url').value,
                enable_limit: document.getElementById('enable-limit').checked,
                download_limit: parseInt(document.getElementById('download-limit').value),
                enable_range: document.getElementById('enable-range').checked,
                download_range_start: parseInt(document.getElementById('range-start').value),
                download_range_end: parseInt(document.getElementById('range-end').value),
                max_workers: parseInt(document.getElementById('max-workers').value),
                enable_retry: document.getElementById('enable-retry').checked,
                retry_count: parseInt(document.getElementById('retry-count').value),
                enable_timeout: document.getElementById('enable-timeout').checked,
                timeout_seconds: parseInt(document.getElementById('timeout-seconds').value)
            };
            
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(config)
                });
                
                const result = await response.json();
                showStatus(result.success ? 'é…ç½®å·²ä¿å­˜' : 'ä¿å­˜å¤±è´¥: ' + result.error, result.success);
                
            } catch (error) {
                showStatus('ä¿å­˜å¤±è´¥: ' + error.message, false);
            }
        }
        
        // åŠ è½½æ’­å®¢åˆ—è¡¨
        async function loadEpisodes() {
            const url = document.getElementById('podcast-url').value;
            if (!url) {
                showStatus('è¯·è¾“å…¥æ’­å®¢åˆ—è¡¨åœ°å€', false);
                return;
            }
            
            showLoading(true);
            
            // è·å–é…ç½®
            const enableLimit = document.getElementById('enable-limit').checked;
            const downloadLimit = parseInt(document.getElementById('download-limit').value);
            const enableRange = document.getElementById('enable-range').checked;
            const rangeStart = parseInt(document.getElementById('range-start').value);
            const rangeEnd = parseInt(document.getElementById('range-end').value);
            const maxWorkers = parseInt(document.getElementById('max-workers').value);
            const batchSize = parseInt(document.getElementById('batch-size').value);
            
            const config = {
                podcast_url: url,
                enable_limit: enableLimit,
                download_limit: downloadLimit,
                enable_range: enableRange,
                download_range_start: rangeStart,
                download_range_end: rangeEnd,
                max_workers: maxWorkers,
                batch_size: batchSize
            };
            
            try {
                const response = await fetch('/api/load-episodes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(config)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentEpisodes = result.episodes;
                    displayEpisodesForSelection(currentEpisodes);
                    document.getElementById('episodes-selection').style.display = 'block';
                    showStatus(`æˆåŠŸåŠ è½½ ${result.episodes.length} ä¸ªæ’­å®¢`, true);
                } else {
                    showStatus('åŠ è½½å¤±è´¥: ' + result.error, false);
                }
                
            } catch (error) {
                showStatus('åŠ è½½å¤±è´¥: ' + error.message, false);
            } finally {
                showLoading(false);
            }
        }
        
        // æ˜¾ç¤ºæ’­å®¢åˆ—è¡¨ä¾›é€‰æ‹©
        function displayEpisodesForSelection(episodes) {
            const container = document.getElementById('episodes-list-container');
            container.innerHTML = '';
            
            if (episodes.length === 0) {
                container.innerHTML = '<p>æ²¡æœ‰æ‰¾åˆ°æ’­å®¢æ•°æ®</p>';
                return;
            }
            
            episodes.forEach((episode, index) => {
                // å¤„ç†æ•°ç»„æ ¼å¼çš„æ’­å®¢æ•°æ® [æ ‡é¢˜, URL]
                const title = Array.isArray(episode) ? episode[0] : episode.title;
                const url = Array.isArray(episode) ? episode[1] : episode.url;
                
                const div = document.createElement('div');
                div.className = 'episode-item';
                div.innerHTML = `
                    <input type="checkbox" class="episode-checkbox" id="episode-${index}" data-index="${index}">
                    <label for="episode-${index}" class="episode-title">${escapeHtml(title)}</label>
                `;
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
                div.addEventListener('click', function(e) {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯å¤é€‰æ¡†æœ¬èº«ï¼Œåˆ™ä¸å¤„ç†
                    if (e.target.type === 'checkbox') return;
                    
                    // åˆ‡æ¢å¤é€‰æ¡†çŠ¶æ€
                    const checkbox = div.querySelector('.episode-checkbox');
                    checkbox.checked = !checkbox.checked;
                    
                    // æ›´æ–°é€‰ä¸­çŠ¶æ€
                    if (checkbox.checked) {
                        selectedEpisodes.add(parseInt(checkbox.dataset.index));
                        div.classList.add('selected');
                    } else {
                        selectedEpisodes.delete(parseInt(checkbox.dataset.index));
                        div.classList.remove('selected');
                    }
                    
                    updateSelectionCount();
                });
                
                // æ·»åŠ å¤é€‰æ¡†å˜åŒ–äº‹ä»¶ç›‘å¬å™¨
                const checkbox = div.querySelector('.episode-checkbox');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedEpisodes.add(parseInt(this.dataset.index));
                        div.classList.add('selected');
                    } else {
                        selectedEpisodes.delete(parseInt(this.dataset.index));
                        div.classList.remove('selected');
                    }
                    updateSelectionCount();
                });
                
                container.appendChild(div);
            });
            
            // å¯ç”¨ä¸‹è½½æŒ‰é’®
            document.getElementById('downloadSelected').disabled = false;
            
            // æ›´æ–°é€‰æ‹©è®¡æ•°
            updateSelectionCount();
        }
        
        // æ›´æ–°é€‰æ‹©è®¡æ•°
        function updateSelectionCount() {
            document.getElementById('selected-count').textContent = selectedEpisodes.size;
        }
        
        // å…¨é€‰
        function selectAll() {
            const checkboxes = document.querySelectorAll('.episode-checkbox');
            checkboxes.forEach(checkbox => {
                if (!checkbox.checked) {
                    checkbox.checked = true;
                    selectedEpisodes.add(parseInt(checkbox.dataset.index));
                    checkbox.parentElement.classList.add('selected');
                }
            });
            updateSelectionCount();
        }
        
        // å…¨ä¸é€‰
        function deselectAll() {
            const checkboxes = document.querySelectorAll('.episode-checkbox');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    checkbox.checked = false;
                    selectedEpisodes.delete(parseInt(checkbox.dataset.index));
                    checkbox.parentElement.classList.remove('selected');
                }
            });
            updateSelectionCount();
        }
        
        // åé€‰
        function invertSelection() {
            const checkboxes = document.querySelectorAll('.episode-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = !checkbox.checked;
                if (checkbox.checked) {
                    selectedEpisodes.add(parseInt(checkbox.dataset.index));
                    checkbox.parentElement.classList.add('selected');
                } else {
                    selectedEpisodes.delete(parseInt(checkbox.dataset.index));
                    checkbox.parentElement.classList.remove('selected');
                }
            });
            updateSelectionCount();
        }
        
        // ä»0å¼€å§‹é€‰æ‹©
        function selectFromZero() {
            // å…ˆå…¨ä¸é€‰
            deselectAll();
            
            // è·å–èŒƒå›´è®¾ç½®
            const enableRange = document.getElementById('enable-range').checked;
            const rangeStart = parseInt(document.getElementById('range-start').value);
            const rangeEnd = parseInt(document.getElementById('range-end').value);
            
            let count = 0;
            if (enableRange) {
                count = rangeEnd - rangeStart;
            } else {
                // å¦‚æœæ²¡æœ‰å¯ç”¨èŒƒå›´ï¼Œåˆ™é»˜è®¤é€‰æ‹©å‰10ä¸ª
                count = Math.min(10, currentEpisodes.length);
            }
            
            // é€‰æ‹©å‰countä¸ª
            const checkboxes = document.querySelectorAll('.episode-checkbox');
            for (let i = 0; i < Math.min(count, checkboxes.length); i++) {
                const checkbox = checkboxes[i];
                checkbox.checked = true;
                selectedEpisodes.add(parseInt(checkbox.dataset.index));
                checkbox.parentElement.classList.add('selected');
            }
            
            updateSelectionCount();
        }
        
        // ä¸‹è½½é€‰ä¸­çš„æ’­å®¢
        async function downloadSelected() {
            if (selectedEpisodes.size === 0) {
                showStatus('è¯·å…ˆé€‰æ‹©è¦ä¸‹è½½çš„æ’­å®¢', false);
                return;
            }
            
            const selectedData = Array.from(selectedEpisodes).map(index => currentEpisodes[index]);
            
            // è·å–ä¸‹è½½é…ç½®
            const enableLimit = document.getElementById('enable-limit').checked;
            const downloadLimit = parseInt(document.getElementById('download-limit').value);
            const enableRange = document.getElementById('enable-range').checked;
            const rangeStart = parseInt(document.getElementById('range-start').value);
            const rangeEnd = parseInt(document.getElementById('range-end').value);
            
            // è®¡ç®—å®é™…å°†è¦ä¸‹è½½çš„æ•°é‡
            let actualDownloadCount = selectedData.length;
            
            if (enableLimit && selectedData.length > downloadLimit) {
                actualDownloadCount = downloadLimit;
            }
            
            if (enableRange) {
                const rangeCount = rangeEnd - rangeStart;
                if (actualDownloadCount > rangeCount) {
                    actualDownloadCount = rangeCount;
                }
            }
            
            // æ˜¾ç¤ºä¸‹è½½ä¿¡æ¯
            if (actualDownloadCount < selectedData.length) {
                showStatus(`âš ï¸ é€‰æ‹©äº† ${selectedData.length} ä¸ªï¼Œä½†é™åˆ¶ä¸º ${actualDownloadCount} ä¸ªï¼Œå°†åªä¸‹è½½å‰ ${actualDownloadCount} ä¸ª`, true);
            }
            
            // å®‰å…¨åœ°è·å–é…ç½®å€¼
            const getValue = (id, defaultValue = '') => {
                const element = document.getElementById(id);
                return element ? element.value : defaultValue;
            };
            
            const getChecked = (id) => {
                const element = document.getElementById(id);
                return element ? element.checked : false;
            };
            
            const getNumber = (id, defaultValue = 0) => {
                const element = document.getElementById(id);
                return element ? parseInt(element.value) || defaultValue : defaultValue;
            };
            
            const maxWorkers = getNumber('max-workers', 5);
            
            // è·å–ä¸‹è½½é€‰é¡¹
            const downloadOptions = {
                quality: 'medium',  // é»˜è®¤ä¸­ç­‰è´¨é‡
                format: 'mp3',       // é»˜è®¤MP3æ ¼å¼
                enable_retry: getChecked('enable-retry'),
                retry_count: getNumber('retry-count', 3),
                enable_timeout: getChecked('enable-timeout'),
                timeout_seconds: getNumber('timeout-seconds', 60)
            };
            
            showStatus(`å¼€å§‹ä¸‹è½½ ${actualDownloadCount} ä¸ªæ’­å®¢...`, true);
            
            try {
                // åˆ›å»ºæ§åˆ¶å™¨ä»¥æ”¯æŒè¶…æ—¶è®¾ç½®
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000); // 5åˆ†é’Ÿè¶…æ—¶
                
                const response = await fetch('/api/download', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        episodes: selectedData.slice(0, actualDownloadCount),
                        max_workers: maxWorkers,
                        download_options: downloadOptions
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const result = await response.json();
                
                if (result.success) {
                    showStatus(result.message, true);
                    // å¼€å§‹ç›‘æ§ä¸‹è½½çŠ¶æ€
                    monitorDownloadStatus();
                } else {
                    showStatus('ä¸‹è½½å¤±è´¥: ' + result.error, false);
                }
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    showStatus('ä¸‹è½½è¯·æ±‚è¶…æ—¶ (5åˆ†é’Ÿ)ï¼Œä½†åå°ä»åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨åæŸ¥çœ‹ä¸‹è½½çŠ¶æ€', false);
                } else {
                    showStatus('ä¸‹è½½å¤±è´¥: ' + error.message, false);
                }
            }
        }
        
        // ç›‘æ§ä¸‹è½½çŠ¶æ€
        function monitorDownloadStatus() {
            const statusInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/download-status');
                    const result = await response.json();
                    
                    if (result.success) {
                        const status = result.status;
                        const total = status.total;
                        const completed = status.completed;
                        const failed = status.failed;
                        
                        if (total > 0) {
                            const progress = (completed / total) * 100;
                            
                            // æ›´æ–°çŠ¶æ€æ¶ˆæ¯ï¼ŒåŒ…å«æ›´è¯¦ç»†ä¿¡æ¯
                            let statusMessage = `ä¸‹è½½è¿›åº¦: ${completed}/${total} (${progress.toFixed(1)}%)`;
                            
                            // æ˜¾ç¤ºå½“å‰ä¸‹è½½çš„æ–‡ä»¶
                            const currentDownloads = status.current_downloads;
                            const downloadingCount = Object.keys(currentDownloads).filter(title => 
                                currentDownloads[title] === 'downloading'
                            ).length;
                            
                            if (downloadingCount > 0) {
                                statusMessage += ` | æ­£åœ¨ä¸‹è½½: ${downloadingCount} ä¸ªæ–‡ä»¶`;
                            }
                            
                            if (failed > 0) {
                                statusMessage += ` | å¤±è´¥: ${failed} ä¸ª`;
                            }
                            
                            showStatus(statusMessage, true);
                            
                            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
                            if (completed + failed >= total) {
                                clearInterval(statusInterval);
                                if (failed > 0) {
                                    showStatus(`ä¸‹è½½å®Œæˆ: æˆåŠŸ ${completed} ä¸ª, å¤±è´¥ ${failed} ä¸ª`, false);
                                } else {
                                    showStatus(`ä¸‹è½½å®Œæˆ: æˆåŠŸ ${completed} ä¸ªæ’­å®¢ï¼`, true);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('è·å–ä¸‹è½½çŠ¶æ€å¤±è´¥:', error);
                }
            }, 2000); // æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡
        }
        
        // å·¥å…·å‡½æ•°
        function showStatus(message, isSuccess) {
            const statusEl = document.getElementById('status-message');
            statusEl.textContent = message;
            statusEl.className = 'status-message ' + (isSuccess === true ? 'status-success' : isSuccess === false ? 'status-error' : 'status-info');
            statusEl.style.display = 'block';
            
            // 3ç§’åè‡ªåŠ¨éšè—
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }
        
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>